【Skill vs MCP】根本就不存在谁取代谁的问题

全网都在喊"Skill 省 token 替代 MCP"。这是外行话。它俩解决的问题压根不在一个层面。

━━━━━━━━━━━━━━━━━━━━

◆ 先说结论

这篇文章要纠正一个正在快速传播的误解。

最近 Claude Code 推出了 Skill 机制，一堆自媒体开始写"Skill 替代 MCP，省 token"。仔细拆解之后，发现这个说法几乎每个字都有问题：

• Skill 并不总是省 token
• Skill 不能替代 MCP
• 它俩干的活完全不一样

下面逐条解释。

━━━━━━━━━━━━━━━━━━━━

◆ MCP 到底是什么

💡 MCP（Model Context Protocol）：一个「协议」，让 AI agent 能调用外部工具和服务。就像 USB 协议让电脑能连打印机、摄像头一样，MCP 让 AI 能连数据库、GitHub、Jira。

MCP 的核心技术栈很简单：

• 通信方式：JSON-RPC（一种远程调用协议）
• 工具描述：JSON Schema（用结构化格式告诉 AI "这个工具叫什么、接受什么参数、返回什么结果"）
• 传输层：stdio（本地进程）、HTTP（远程服务器，推荐）、SSE（服务端推送，已标记 deprecated）

重点来了——在未启用 Tool Search 的默认情况下，MCP 的 tool definition 会被注入到 system prompt 里，「整个对话期间常驻」。

什么意思？你配置了 50 个 MCP 工具，那这 50 个工具的定义，从你开始对话的那一刻起就全部塞进了上下文，不管你用不用。

💡 人话：MCP 就是给 AI 装的"手"。有了手，AI 才能操作外面的东西——查数据库、提 PR、发消息。但这些手的说明书，得一直摆在桌上。

━━━━━━━━━━━━━━━━━━━━

◆ Skill 到底是什么

💡 Skill：一个「文件夹」，里面放着 SKILL.md（markdown 格式的指令文件）和可选的脚本、参考文档。agent 按需读取。

Skill 的文件结构（以官方 docx Skill 为例，详见 https://github.com/anthropics/skills/tree/main/skills/docx）：

  skill-name/
  ├── SKILL.md              （必须，核心指令）
  └── scripts/              （可选，可执行脚本）
      ├── comment.py
      ├── accept_changes.py
      ├── templates/        （XML 模板，5 个文件）
      └── office/           （验证器 + ISO 标准 schema，50+ 个文件）

Skill 的加载是分层的（根据官方文档行为总结）：

  +------------------+---------------------------+------------------+
  | 加载时机         | 内容                      | 大小             |
  +------------------+---------------------------+------------------+
  | 常驻上下文       | name + description 元数据 | ~100 词          |
  | 触发时加载       | SKILL.md 正文             | 1500-5000 词     |
  | 执行中按需读取   | references/ scripts/ 等   | 无上限           |
  +------------------+---------------------------+------------------+

description 始终在上下文里，让 agent 知道有哪些 Skill 可用。SKILL.md 正文在 Skill 被触发时才加载。references 等支撑文件是 agent 在执行过程中觉得需要才去读的。

💡 人话：Skill 就是给 AI 装的"脑子"——教它怎么干活的知识包。一本操作手册，需要的时候翻开，不需要就放着。

━━━━━━━━━━━━━━━━━━━━

◆ 全网在传的"省 token"是怎么回事

误读版本：Skill 比 MCP 省 token，所以 Skill 要取代 MCP。

让我们看看真实数据。

────────────────────

【MCP 的 token 消耗】

单个 MCP tool definition 很小，大概 50-800 token。一个简单工具可能就这样：

  {
    "name": "search_issues",
    "description": "Search GitHub issues",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {"type": "string"},
        "repo": {"type": "string"}
      }
    }
  }

这个定义大概 60-80 token。不贵。

但问题是——「MCP 是全预加载的」。你配了多少工具，全部塞进 system prompt。

  +-------------------+--------------------+
  | MCP 工具数量      | 预加载 token 消耗  |
  +-------------------+--------------------+
  | 5 个工具          | ~1,500 token       |
  | 20 个工具         | ~6,000 token       |
  | 50 个工具         | ~15,000 token      |
  | 极端情况          | 134,000+ token     |
  +-------------------+--------------------+

⚠️ 社区讨论中有人反馈，极端情况下 MCP tool definitions 可以占到 134k token（见参考资料中的 GitHub issue）。你的对话还没开始，上下文窗口就已经被塞了一大半。

这才是 MCP 贵的原因——不是单个工具贵，是「数量 × 全预加载」贵。

────────────────────

【Skill 的 token 消耗】

Skill 常驻的 description 确实很小，~100 词。但一旦被触发加载 SKILL.md 正文……

我翻了官方的 docx Skill 文件（https://github.com/anthropics/skills/tree/main/skills/docx）：

• SKILL.md 单个文件：481 行 ← 触发时一次性全部加载

没有拆分，所有指令、参考文档、代码示例全塞在一个 SKILL.md 里。触发即全量加载。

「单个 Skill 在完整执行过程中消耗的 token，可能比等价的 MCP tool definition 还多。」

━━━━━━━━━━━━━━━━━━━━

◆ Skill 真正省的是什么

不是单次加载量。是「不相关的不加载」。

打个比方：

• MCP = 自助餐全摆桌。你配了 50 个工具，不管今天用不用，50 道菜全摆上来。每道菜可能不大，但 50 道加在一起，桌子满了。

• Skill = 按需点菜。你装了 20 个 Skill，但这次对话只触发了 1 个。只有这 1 个的内容会被加载。

省的是那 19 个没被触发的 Skill 的 token 消耗。

但那 1 个被触发的，可能比你想象的大得多——一个完整的 Skill 展开后（主文件 + 引用文件），内容量经常超过几个 MCP tool definition 加起来的量。

这就是为什么"Skill 省 token"这个说法是「半对半错」的：

  ✓ 对：不相关的 Skill 不消耗 token（MCP 则全部预加载）
  ✗ 错：被触发的单个 Skill 不一定比 MCP 省

━━━━━━━━━━━━━━━━━━━━

◆ 为什么不存在"替代"关系

这是整篇文章最重要的一节。

MCP 和 Skill 解决的问题「根本不在一个层面」：

  +------------+---------------------+------------------------+
  | 维度       | MCP                 | Skill                  |
  +------------+---------------------+------------------------+
  | 本质       | 连接外部服务的管道  | 教 agent 干活的知识    |
  | 类比       | 手                  | 脑子                   |
  | 功能       | "能做什么"          | "怎么做"               |
  | 举例       | 连 GitHub API       | 教 agent 怎么写好代码  |
  |            | 查数据库            | 教 agent 怎么做 review |
  |            | 操作文件系统        | 教 agent 遵循规范      |
  | 技术实现   | JSON-RPC + Server   | Markdown 文件夹        |
  | 运行时需求 | 需要 server 进程    | 不需要                 |
  +------------+---------------------+------------------------+

用人话说：

• 你不能用 Skill 去查 GitHub issues——因为 Skill 只是一份文档，它没有"手"去调 API
• 你不能用 MCP 去教 agent 怎么写高质量代码——MCP 只定义了"有哪些工具可以调"，它没有"脑子"来传授方法论

这就像说"教科书要替代螺丝刀"——一个是知识，一个是工具，怎么替代？

────────────────────

【实际场景对比】

场景一：你想让 AI 帮你在 Jira 上创建任务。

→ 需要 MCP。因为 AI 得调用 Jira API，这是一个外部服务的操作。Skill 做不到这件事——它只是文档，不能发 HTTP 请求。

场景二：你想让 AI 按照你们公司的代码规范来写 React 组件。

→ 需要 Skill。因为 AI 得知道你们的规范是什么、组件结构应该怎么写、命名应该怎么起。MCP 帮不了这个忙——它是连接服务的管道，不是教学手册。

场景三：你想让 AI 查 GitHub PR 的评论，然后按照团队规范给出 review 意见。

→ 两个都需要。MCP 负责连 GitHub 拿到 PR 数据（手），Skill 负责告诉 agent 怎么做 review（脑子）。实际上 SKILL.md 里可以直接写"调用 GitHub MCP 工具拉取 PR 数据"——Skill 编排流程，MCP 执行操作，这就是典型的混用场景。

「它们是协作关系，不是竞争关系。」

━━━━━━━━━━━━━━━━━━━━

◆ Skill 真正的优势：零门槛

如果非要说 Skill 比 MCP 强在哪，只有一条：「不用搞服务器」。

配置一个 MCP 工具你需要：

• 写一个 MCP server（或者用现成的 npm 包）
• 配置传输层（stdio / HTTP / SSE）
• 处理认证（OAuth / Token / 环境变量）
• 管理进程生命周期（启动、重连、清理）
• 写 JSON 配置文件
• debug 连接问题（用 claude --debug 看日志）

配置一个 Skill 你需要：

• 建一个文件夹
• 写一个 SKILL.md

就这样。一个 markdown 文件。

任何人都能写 Skill。你不需要懂 JSON-RPC，不需要起 server，不需要配 OAuth。你只要会写人话，把操作步骤用 markdown 写清楚就行。

这才是 Skill 真正降低的门槛——不是 token 的门槛，是「创作和分发的门槛」。

━━━━━━━━━━━━━━━━━━━━

◆ MCP 也在进化

有人可能会说："MCP 全预加载确实浪费，所以 Skill 迟早取代它。"

且慢。MCP 协议自己也在演进。

事实上，「MCP Tool Search」已经发布了——当你的 MCP 工具描述占上下文窗口超过 10% 时，Claude Code 会自动启用按需加载，而不是一股脑全塞进去。思路和 Skill 的分层加载一模一样。

也就是说，MCP 的 token 预加载问题「已经在被解决了」。"Skill 比 MCP 省 token"这个论点会随着 MCP 自身的演进越来越弱。

用当前的实现细节去做长期判断，本身就是一个错误。协议在演进，实现会变，唯一不变的是它们各自解决的问题：

• MCP 解决的是「连接」问题——AI 怎么和外部世界交互
• Skill 解决的是「知识」问题——AI 怎么用正确的方式干活

这两个问题永远同时存在。

━━━━━━━━━━━━━━━━━━━━

◆ 一张图看清楚

把 MCP 和 Skill 的关系画出来：

【插图 assets/83/skill-vs-mcp.png】

脑子和手不是二选一的关系。你需要两个都有。

━━━━━━━━━━━━━━━━━━━━

◆ 写在最后

技术圈有个通病：每出一个新东西，就要找一个旧东西来"杀"。

Kubernetes 要杀 Docker。GraphQL 要杀 REST。现在轮到 Skill 要杀 MCP 了。

但真正理解技术的人知道，大多数时候新东西和旧东西解决的是不同的问题，或者同一个问题的不同侧面。它们最终的归宿不是你死我活，而是各司其职。

Skill 是知识，MCP 是管道。一个装脑子，一个装手。

「你不会因为学会了思考，就把手砍掉。」

━━━━━━━━━━━━━━━━━━━━

◆ 参考资料

• Anthropic 官方博文：https://claude.com/blog/equipping-agents-for-the-real-world-with-agent-skills
• MCP 官方文档：https://modelcontextprotocol.io/
• Claude Code Skills 文档：https://code.claude.com/docs/en/skills
• MCP Token Bloat 讨论：https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1576
• Armin Ronacher 技术对比：https://lucumr.pocoo.org/2025/12/13/skills-vs-mcp/

━━━━━━━━━━━━━━━━━━━━

// 靳岩岩的 AI 学习笔记 × Claude 的严谨 × Gemini 的浪漫 
// 2026-02-11
